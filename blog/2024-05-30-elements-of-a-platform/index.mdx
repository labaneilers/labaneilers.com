---
slug: elements-of-a-platform
title: Elements of a platform
tags: [devops, platform-engineering, kubernetes]
draft: true
---

I've mentioned a few times in this blog that I've been iterating on a Kubernetes developer platform across several different companies. The last one in particular, called `dex`, has really caught on at SimpliSafe, and is having a big impact on our engineering team. 

I thought it might be useful to share an overview of the architecture, and see what people think of the patterns I've settled on.

## Base components

You can think of `dex` as a client-side tool that encapsulates all of SimpliSafe's opinions about infrastructure and our software lifecycle. Here's the components that are "glued together" by `dex`:

* AWS
  * Multi-account architecture
  * SSM Parameter Store and Secrets Manager
* Kubernetes (EKS)
    * Karpenter
    * AWS Load Balancer Controller
    * external-dns
    * external-secrets
    * kyverno
    * velero
    * coredns and node-local-dns
    * fluent bit
    * OTEL collector (using prometheus receiver)
    * IAM integration via OIDC
* Docker and BuildKit
* Github and Github Actions
* Grafana Cloud
* OpenSearch
* Honeycomb

Security solutions, but I don't want to get into the details of those.

## CLI and a Library

dex is separated into two parts: a CLI tool and a library. 

The CLI tool, `dx`, is installed globally, and doesn't change often. It's fairly minimal, and just passes most CLI arguments through to an entrypoint defined in the dex library in your project and pass it commands/arguments. `dx` doesn't change often, and is designed to be broadly compatible as the dex library evolves.

The library gets installed in a project, and is where almost all the logic lives. This allows the version of dex to be locked in a project, so users don't get upgrades without explicitly deciding they want them.

:::info
We've made an explicit tradeoff in putting the logic into a client library that gets upgraded at the discretion of developers, and that we don't have centralized control over this. We believe this is a good tradeoff, and aligns with our culture of autonomy and developer empowerment.

For important security or operational controls, we have Kyverno in our EKS clusters, which allows us to define policies that are enforced at the cluster level.
:::

`dx` and `dex` are both written in TypeScript, mostly because extensibility and hackability were core values of the project. Even though `dex` is written in TypeScript, it has no opinions about the language, tooling, or frameworks used in the project.

## Configuration

There's a number of configuration management systems for Kubernetes available, but I've found that this is an area where having tight integration with your company's infrastructure choices has a huge impact on usability.

`dex`'s configuration system allows users to define arbitrary environments as a YAML tree, and then these can be inherited by other environments. A typical environment hierarchy might look like this:

```
project          # root: all envs inherit from this
├── qa           # shared integration env
│   ├── feature  # feature branch env
│   └── dev      # local developer env
├── stg          # pre-production env
└── prd          # production
```

All commands in dex respect the environment variable `DEX_ENV`, which selects the name of the environment to use for that invocation.

* Automatic translation from single config definition to Kubernetes, Docker, and local processes (for running locally and debugging)
* Extensibility via "config generators", which allow a user to define a functions to generate config values dynamically
* Secrets get referenced from config and are automatically resolved

Here's an example environment definition config files with some inheritance:

```yaml {title="project.yaml"}
apps:
  main:
    name: "device-listener"
    aws:
      team: "devices"
      region: "us-west-1"
    slack:
      iconEmoji: ":dex:"
    kubernetes:
      ingressType: internalIngressAndService
    env:
      DATABASE_USERNAME: "@secret /apps/listener/username"
      DATABASE_PASSWORD: "@secret /apps/listener/password"
      POLLING_INTERVAL_SECONDS: "5"
      LOG_LEVEL: "debug"
```

```yaml {title="qa.yaml"}
apps:
  main:
    aws:
      accountEnv: "qa"
    slack:
      channel: "#qa-deploys"
    containerImage:
      tag: "@generator mainBranch.tag()"
    kubernetes:
      additionalHostnames:
      - "listener.qa.services.simplisafe.com"
    env:
      DATABASE_URL: "some-mongodb.private.network"
      LOG_LEVEL: "info"
```

This config gets merged